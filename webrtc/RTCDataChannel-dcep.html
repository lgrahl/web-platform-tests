<!doctype html>
<meta charset=utf-8>
<title>RTCDataChannel DCEP</title>
<script src=/resources/testharness.js></script>
<script src=/resources/testharnessreport.js></script>
<script src="RTCPeerConnection-helper.js"></script>
<script>
'use strict';

// Test is based on the following revision:
// https://rawgit.com/w3c/webrtc-pc/1cc5bfc3ff18741033d804c4a71f7891242fb5b3/webrtc.html

/*
  Check that DCEP-negotiated data channels transmit all options correctly.
  See: https://tools.ietf.org/html/draft-ietf-rtcweb-data-protocol-09

  Note: Some of these tests may seem redundant on first sight but if you take a look at
        the channel types defined by DCEP, they should make sense to you.
 */

promise_test(t => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  // DATA_CHANNEL_RELIABLE (0x00)
  return createDataChannelPair(pc1, pc2, {
    channelOptions: { ordered: true }
  })
  .then(([channel1, channel2]) => {
    assert_equals(channel1.ordered, true);
    assert_equals(channel2.ordered, true);
  });
}, 'Ordered and reliable channel should be created via DCEP');

promise_test(t => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  // DATA_CHANNEL_RELIABLE_UNORDERED (0x80)
  return createDataChannelPair(pc1, pc2, {
    channelOptions: { ordered: false }
  })
  .then(([channel1, channel2]) => {
    assert_equals(channel1.ordered, false);
    assert_equals(channel2.ordered, false);
  });
}, 'Unordered and reliable channel should be created via DCEP');

promise_test(t => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  // DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT (0x01)
  return createDataChannelPair(pc1, pc2, {
    channelOptions: {
      ordered: true,
      maxRetransmits: 4294967295
    }
  })
  .then(([channel1, channel2]) => {
    assert_equals(channel1.ordered, true);
    assert_equals(channel2.ordered, true);
    assert_equals(channel1.maxRetransmits, 4294967295);
    assert_equals(channel2.maxRetransmits, 4294967295);
  });
}, 'Ordered and unreliable (maxRetransmits) channel should be created via DCEP');

promise_test(t => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  // DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT_UNORDERED (0x81)
  return createDataChannelPair(pc1, pc2, {
    channelOptions: {
      ordered: false,
      maxRetransmits: 4294967295
    }
  })
  .then(([channel1, channel2]) => {
    assert_equals(channel1.ordered, false);
    assert_equals(channel2.ordered, false);
    assert_equals(channel1.maxRetransmits, 4294967295);
    assert_equals(channel2.maxRetransmits, 4294967295);
  });
}, 'Unordered and unreliable (maxRetransmits) channel should be created via DCEP');

promise_test(t => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  // DATA_CHANNEL_PARTIAL_RELIABLE_TIMED (0x02)
  return createDataChannelPair(pc1, pc2, {
    channelOptions: {
      ordered: true,
      maxPacketLifeTime: 4294967295
    }
  })
  .then(([channel1, channel2]) => {
    assert_equals(channel1.ordered, true);
    assert_equals(channel2.ordered, true);
    assert_equals(channel1.maxPacketLifeTime, 4294967295);
    assert_equals(channel2.maxPacketLifeTime, 4294967295);
  });
}, 'Ordered and unreliable (maxPacketLifeTime) channel should be created via DCEP');

promise_test(t => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  // DATA_CHANNEL_PARTIAL_RELIABLE_TIMED_UNORDERED (0x82)
  return createDataChannelPair(pc1, pc2, {
    channelOptions: {
      ordered: false,
      maxPacketLifeTime: 4294967295
    }
  })
  .then(([channel1, channel2]) => {
    assert_equals(channel1.ordered, false);
    assert_equals(channel2.ordered, false);
    assert_equals(channel1.maxPacketLifeTime, 4294967295);
    assert_equals(channel2.maxPacketLifeTime, 4294967295);
  });
}, 'Unordered and unreliable (maxPacketLifeTime) channel should be created via DCEP');

promise_test(t => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  return createDataChannelPair(pc1, pc2, {
    channelOptions: {
      priority: 'high'
    }
  })
  .then(([channel1, channel2]) => {
    assert_equals(channel1.priority, 'high');
    assert_equals(channel2.priority, 'high');
  });
}, 'Channel with priority set to high should be created via DCEP');

promise_test(t => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  return createDataChannelPair(pc1, pc2)
  .then(([channel1, channel2]) => {
    assert_greater_than_equal(channel1.id, 0, 'Expect id to be >= 0');
    assert_less_than(channel1.id, 65535, 'Expect id to be < 65535');
    assert_equals(channel1.id, channel2.id);
  });
}, 'Channel IDs should be synchronized when created via DCEP');

promise_test(t => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  const label = '';
  const protocol = '';

  return createDataChannelPair(pc1, pc2, {
    channelLabel: label,
    channelOptions: {
      protocol: protocol
    }
  })
  .then(([channel1, channel2]) => {
    assert_equals(channel1.label, label);
    assert_equals(channel2.label, label);
    assert_equals(channel1.protocol, protocol);
    assert_equals(channel2.protocol, protocol);
  });
}, 'Zero length label and protocol option should be transmitted via DCEP');

promise_test(t => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  const label = 'l'.repeat(65535);
  const protocol = 'p'.repeat(65535);

  t.step_timeout(() => assert_unreached('Channel did not open in time'), 5000);
  return createDataChannelPair(pc1, pc2, {
    channelLabel: label,
    channelOptions: {
      protocol: protocol
    }
  })
  .then(([channel1, channel2]) => {
    assert_equals(channel1.label, label);
    assert_equals(channel2.label, label);
    assert_equals(channel1.protocol, protocol);
    assert_equals(channel2.protocol, protocol);
  });
}, 'Maximum length label and protocol option should be transmitted via DCEP');

</script>
