<!doctype html>
<meta charset=utf-8>
<meta name=timeout content=long>
<title>RTCDataChannel id attribute</title>
<script src=/resources/testharness.js></script>
<script src=/resources/testharnessreport.js></script>
<script src="RTCPeerConnection-helper.js"></script>
<script>
'use strict';

// Test is based on the following revision:
// https://rawgit.com/w3c/webrtc-pc/1cc5bfc3ff18741033d804c4a71f7891242fb5b3/webrtc.html

// This is the maximum number of streams, NOT the maximum stream ID (which is 65534)
// See: https://tools.ietf.org/html/draft-ietf-rtcweb-data-channel-13#section-6.2
const nStreams = 65535;

/*
  6.1.
    21. If the [[DataChannelId]] slot is null (due to no ID being passed into
        createDataChannel, or [[Negotiated]] being false), and the DTLS role of the SCTP
        transport has already been negotiated, then initialize [[DataChannelId]] to a value
        generated by the user agent, according to [RTCWEB-DATA-PROTOCOL] [...]
 */
promise_test(t => {
  const pc = new RTCPeerConnection;
  test.add_cleanup(() => pc.close());
  const channel = pc.createDataChannel('');

  return pc.createOffer()
  .then(offer => pc.setLocalDescription(offer))
  .then(() => {
    // Turn our own offer SDP into valid answer SDP by setting the DTLS role to
    // "active".
    const answer = {
      type: "answer",
      sdp: pc.localDescription.sdp.replace("actpass", "active")
    };
    return pc.setRemoteDescription(answer);
  })
  .then(() => {
    // Since the remote description had an "active" DTLS role, we're the server
    // and should use odd data channel IDs, according to rtcweb-data-channel.
    assert_equals(channel.id % 2, 1,
      `Channel created by the DTLS server role must be odd (was ${channel.id})`);
    const another_channel = pc.createDataChannel('another');
    assert_equals(another_channel.id % 2, 1,
      `Channel created by the DTLS server role must be odd (was ${channel.id})`);
    assert_not_equals(channel.id, another_channel.id);
  })
}, "DTLS client uses odd data channel IDs");

promise_test(t => {
  const pc = new RTCPeerConnection;
  test.add_cleanup(() => pc.close());
  const channel = pc.createDataChannel('');

  return pc.createOffer()
  .then(offer => pc.setLocalDescription(offer))
  .then(() => {
    // Turn our own offer SDP into valid answer SDP by setting the DTLS role to
    // "passive".
    const answer = {
      type: "answer",
      sdp: pc.localDescription.sdp.replace("actpass", "passive")
    };
    return pc.setRemoteDescription(answer);
  })
  .then(() => {
    // Since the remote description had a "passive" DTLS role, we're the client
    // and should use even data channel IDs, according to rtcweb-data-channel.
    assert_equals(channel.id % 2, 0,
      `Channel created by the DTLS client role must be even (was ${channel.id})`);
    const another_channel = pc.createDataChannel('another');
    assert_equals(another_channel.id % 2, 0,
      `Channel created by the DTLS client role must be even (was ${channel.id})`);
    assert_not_equals(channel.id, another_channel.id);
  })
}, "DTLS server uses even data channel IDs");

/*
  Create 32768 (client), 32767 (server) channels to make sure all ids are exhausted AFTER
  establishing a peer connection.

  6.1.  createDataChannel
    21. If the [[DataChannelId]] slot is null (due to no ID being passed into
        createDataChannel, or [[Negotiated]] being false), and the DTLS role of the SCTP
        transport has already been negotiated, then initialize [[DataChannelId]] to a value
        generated by the user agent, according to [RTCWEB-DATA-PROTOCOL], and skip
        to the next step. If no available ID could be generated, or if the value of the
        [[DataChannelId]] slot is being used by an existing RTCDataChannel, throw an
        OperationError exception.
 */

promise_test(t => {
  // Takes the DTLS server role
  const pc1 = new RTCPeerConnection();
  // Takes the DTLS client role
  const pc2 = new RTCPeerConnection();

  // Used to force keeping a reference to the channels
  let channels = [];

  // We need the initial data channel on the DTLS server side to ensure the peer connection
  // will be established
  return createDataChannelPair(pc1, pc2, 'initial', {
    offer: (offer) => {
      // Ensure pc1 takes the server role
      assert_true(offer.sdp.includes('actpass') || offer.sdp.includes('passive'),
        'pc1 must take the DTLS server role');
      return offer;
    },
    answer: (answer) => {
      // Ensure pc2 takes the client role
      // Note: It very likely will choose 'active' itself
      answer.sdp = answer.sdp.replace('actpass', 'active');
      assert_true(answer.sdp.includes('active'), 'pc2 must take the DTLS client role');
      return answer;
    },
  }).then(([dc1, dc2]) => {
    // At this point, one channel id is already taken and it MUST be odd since pc1 created it
    assert_equals(dc1.id % 2, 1,
      `Channel created by the DTLS server role must be odd (was ${dc1.id})`);
    assert_equals(dc2.id % 2, 1,
      `Channel created by the DTLS server role must be odd (was ${dc2.id})`);

    // Create 65534 further channels
    // Note: Since 65535 streams is a SHOULD, we may have less than that
    for (let i = 1; i < nStreams; ++i) {
      let dc;

      // The first two channels and all even streams need to be created by pc2
      if (i < 2 || i % 2 === 0) {
        try {
          dc = pc2.createDataChannel('this is going to be fun');
        } catch (e) {
          console.warn(`Only ${i} streams are supported (spec says 'SHOULD' support ${nStreams})`);
          assert_equals(e.name, 'OperationError', 'Fail on creation should throw OperationError');
          break;
        }
        assert_equals(dc.id % 2, 0,
          `Channel #${i + 2} created by the DTLS client role must be even (was ${dc.id})`);
      } else {
        try {
          dc = pc1.createDataChannel('this is going to be fun, too');
        } catch (e) {
          console.warn(`Only ${i} streams are supported (spec says 'SHOULD' support ${nStreams})`);
          assert_equals(e.name, 'OperationError', 'Fail on creation should throw OperationError');
          break;
        }
        assert_equals(dc.id % 2, 1,
          `Channel #${i + 2} created by the DTLS server role must be odd (was ${dc.id})`);
      }

      channels.push(dc);
    }

    // Try creating one further channel on both sides. The attempt should fail.
    assert_throws('OperationError', () =>
      pc1.createDataChannel('this is too exhausting!'));
    assert_throws('OperationError', () =>
      pc2.createDataChannel('this is too exhausting!'));
  });
}, 'Creating a channel after exhausting the maximum number of channels should throw' +
  'OperationError (after connection establishment)');

/*
  Create channels until exhaustion, close one, open one (this should work), open another
  (this should fail).
 */
promise_test(t => {
  // Takes the DTLS server role
  const pc1 = new RTCPeerConnection();
  // Takes the DTLS client role
  const pc2 = new RTCPeerConnection();

  // Used to force keeping a reference to the channels
  let channels = [];

  // We need the initial data channel on the DTLS server side to ensure the peer connection
  // will be established
  return createDataChannelPair(pc1, pc2, 'initial', {
    offer: (offer) => {
      // Ensure pc1 takes the server role
      assert_true(offer.sdp.includes('actpass') || offer.sdp.includes('passive'),
        'pc1 must take the DTLS server role');
      return offer;
    },
    answer: (answer) => {
      // Ensure pc2 takes the client role
      // Note: It very likely will choose 'active' itself
      answer.sdp = answer.sdp.replace('actpass', 'active');
      assert_true(answer.sdp.includes('active'), 'pc2 must take the DTLS client role');
      return answer;
    },
  }).then(([dc1, dc2]) => {
    // At this point, one channel id is already taken and it MUST be odd since pc1 created it
    assert_equals(dc1.id % 2, 1,
      `Channel created by the DTLS server role must be odd (was ${dc1.id})`);
    assert_equals(dc2.id % 2, 1,
      `Channel created by the DTLS server role must be odd (was ${dc2.id})`);

    // Create 65534 further channels with pc1
    // Note: Since we do this on pc1 only, IDs should be exhausted after 32767 channels
    for (let i = 1; i < nStreams; ++i) {
      let dc;
      try {
        dc = pc1.createDataChannel('test');
      } catch (e) {
        assert_equals(e.name, 'OperationError', 'Fail on creation should throw OperationError');
        break;
      }
      assert_equals(dc.id % 2, 1,
        `Channel #${i + 2} created by the DTLS server role must be even (was ${dc.id})`);
      channels.push(dc);
    }

    // Try creating one further channel with pc1. The attempt should fail.
    assert_throws('OperationError', () =>
      pc1.createDataChannel('this is too exhausting!'));

    // Close a channel and wait until it's closed
    return new Promise((resolve) => {
      const dc = channels[0];
      const id = dc.id;
      dc.onclose = () => resolve(id);
      dc.close();
    });
  }).then((id) => {
    // Create a new channel, ensure the ID has been reassigned
    const dc = pc1.createDataChannel('reassigned?');
    assert_equals(dc.id, id, `ID should be reassigned to new channel`);
  });
}, 'Channel IDs should be reassigned after exhaustion in case a channel has been closed');

/*
  Create 65535 channels with the DTLS client role. Ensure the odd/even rule is not violated.
 */
promise_test(t => {
  // Takes the DTLS server role
  const pc1 = new RTCPeerConnection();
  // Takes the DTLS client role
  const pc2 = new RTCPeerConnection();

  exchangeIceCandidates(pc1, pc2);
  let channels = [];

  // Create 65535 channels with pc1
  //
  // Note: Following the spec strictly would assume that this cannot fail. But in reality it will
  //       fail because the implementation knows how many streams it supports. What it doesn't
  //       know is how many streams the other peer supports (e.g. what will be negotiated).
  for (let i = 0; i < nStreams; ++i) {
    let dc;
    try {
      dc = pc1.createDataChannel('test');
    } catch (e) {
      assert_equals(e.name, 'OperationError', 'Fail on creation should throw OperationError');
      break;
    }
    assert_equals(dc.id, null, 'Channel id must be null before DTLS role has been determined');
    assert_not_equals(dc.readyState, 'closed',
      'Channel may not be closed before connection establishment');
    channels.push(dc);
  }

  return doSignalingHandshake(pc1, pc2, {
    offer: (offer) => {
      // Ensure pc1 takes the server role
      assert_true(offer.sdp.includes('actpass') || offer.sdp.includes('passive'),
        'pc1 must take the DTLS server role');
      return offer;
    },
    answer: (answer) => {
      // Ensure pc2 takes the client role
      // Note: It very likely will choose 'active' itself
      answer.sdp = answer.sdp.replace('actpass', 'active');
      assert_true(answer.sdp.includes('active'), 'pc2 must take the DTLS client role');
      return answer;
    },
  }).then(() => {
    for (const dc of channels) {
      assert_equals(dc.id % 2, 1,
        `Channel created by the DTLS server role must be odd (was ${dc.id})`);
    }

    // Try creating one further channel on both sides. The attempt should fail since all IDs are
    // taken. If one ID is available, the implementation probably miscounts (or I did in the test).
    assert_throws('OperationError', () =>
      pc1.createDataChannel('this is too exhausting!'));
  });
}, 'Exhausting channels with one peer should not violate the odd/even rule');

/*
  Create 32768 (client), 32767 (server) channels to make sure all ids are exhausted BEFORE
  establishing a peer connection.

  Be aware that late channel id assignment can currently fail in many places not covered by the
  spec, see: https://github.com/w3c/webrtc-pc/issues/1818

  4.4.1.6.
    2.2.6.  If description negotiates the DTLS role of the SCTP transport, and there is an
            RTCDataChannel with a null id, then generate an ID according to [RTCWEB-DATA-PROTOCOL].
            If no available ID could be generated, then run the following steps:
      1.    Let channel be the RTCDataChannel object for which an ID could not be generated.
      2.    Set channel's [[ReadyState]] slot to "closed".
      3.    Fire an event named error with an OperationError exception at channel.
      4.    Fire a simple event named close at channel.
 */
async_test(t => {
  // Takes the DTLS server role
  const pc1 = new RTCPeerConnection();
  // Takes the DTLS client role
  const pc2 = new RTCPeerConnection();

  exchangeIceCandidates(pc1, pc2);
  let channels = [];
  let nExpected = 0;
  let nActualCloses = 0;
  let nActualErrors = 0;

  const maybeDone = t.step_func(() => {
    if (nExpected === nActualCloses && nExpected === nActualErrors) {
      t.done();
    }
  });

  // Create 65535+2 channels (since 65535 streams is a SHOULD, we may have less than that.)
  // Create two extra channels to possibly trigger the steps in the description.
  //
  // Note: Following the spec strictly would assume that this cannot fail. But in reality it will
  //       fail because the implementation knows how many streams it supports. What it doesn't
  //       know is how many streams the other peer supports (e.g. what will be negotiated).
  for (let i = 0; i < (nStreams + 2); ++i) {
    let dc;
    try {
      const pc = i % 2 === 1 ? pc1 : pc2;
      dc = pc.createDataChannel('this is going to be fun');
      dc.onclose = t.step_func(() => {
        ++nActualCloses;
        maybeDone();
      });
      dc.onerror = t.step_func((e) => {
        assert_true(e instanceof RTCError, 'Expect error object to be instance of RTCError');
        assert_equals(e.error, 'sctp-failure', "Expect error to be of type 'sctp-failure'");
        ++nActualErrors;
        maybeDone();
      });
    } catch (e) {
      if (i < nStreams) {
        console.warn(`Only ${i} streams are supported (spec says 'SHOULD' support ${nStreams})`);
      }
      assert_equals(e.name, 'OperationError', 'Fail on creation should throw OperationError');
      break;
    }
    assert_equals(dc.id, null, 'Channel id must be null before DTLS role has been determined');
    assert_not_equals(dc.readyState, 'closed',
      'Channel may not be closed before connection establishment');
    channels.push([dc, i % 2 === 1]);
  }

  doSignalingHandshake(pc1, pc2, {
    offer: (offer) => {
      // Ensure pc1 takes the server role
      assert_true(offer.sdp.includes('actpass') || offer.sdp.includes('passive'),
        'pc1 must take the DTLS server role');
      return offer;
    },
    answer: (answer) => {
      // Ensure pc2 takes the client role
      // Note: It very likely will choose 'active' itself
      answer.sdp = answer.sdp.replace('actpass', 'active');
      assert_true(answer.sdp.includes('active'), 'pc2 must take the DTLS client role');
      return answer;
    },
  }).then(() => {
    // Since the spec does not define a specific order to which channels may fail if an ID could
    // not be generated, any of the channels may be affected by the steps of the description.
    for (const [dc, odd] of channels) {
      if (dc.readyState !== 'closed') {
        assert_equals(dc.id % 2, odd ? 1 : 0,
          `Channels created by the DTLS ${odd ? 'server' : 'client'} role must be
          ${odd ? 'odd' : 'even'} (was ${dc.id})`);
      } else {
        ++nExpected;
      }
    }

    // Try creating one further channel on both sides. The attempt should fail since all IDs are
    // taken. If one ID is available, the implementation probably miscounts (or I did in the test).
    assert_throws('OperationError', () =>
      pc1.createDataChannel('this is too exhausting!'));
    assert_throws('OperationError', () =>
      pc2.createDataChannel('this is too exhausting!'));
  }).then(() => {
    maybeDone();
  }).catch(t.step_func(err =>
    assert_unreached(`Unexpected promise rejection: ${err}`)));
}, 'Channel ID exhaustion handling (before and after connection establishment)');

</script>
