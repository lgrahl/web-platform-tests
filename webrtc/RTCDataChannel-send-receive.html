<!doctype html>
<meta charset=utf-8>
<meta name=timeout content=long>
<title>RTCDataChannel send/receive</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="RTCPeerConnection-helper.js"></script>
<script>
'use strict';

// Test is based on the following revision:
// https://rawgit.com/w3c/webrtc-pc/1cc5bfc3ff18741033d804c4a71f7891242fb5b3/webrtc.html

// The following helper functions are called from RTCPeerConnection-helper.js:
//  createDataChannelPair
//  awaitMessage
//  blobToArrayBuffer
//  assert_equals_typed_array

// Note: bufferedAmount after send is covered in RTCDataChannel-bufferedAmount

/*
  6.2.  RTCDataChannel
    interface RTCDataChannel : EventTarget {
      ...
      readonly  attribute RTCDataChannelState readyState;
      readonly  attribute unsigned long       bufferedAmount;
                attribute EventHandler        onmessage;
                attribute DOMString           binaryType;

      void send(USVString data);
      void send(Blob data);
      void send(ArrayBuffer data);
      void send(ArrayBufferView data);
    };
 */

// Simple ASCII encoded string
const helloString = 'hello';
// ASCII encoded buffer representation of the string
const helloBuffer = Uint8Array.of(0x68, 0x65, 0x6c, 0x6c, 0x6f);
const helloBlob = new Blob([helloBuffer]);
// Unicode string with multiple code units
const unicodeString = '世界你好';

// Array buffer types to test
const arrayBuffers = [
  ['Int8Array', Int8Array.of(127, 126, 0, -128)],
  ['Uint8Array', Uint8Array.of(255, 254, 253, 0)],
  ['Uint8ClampedArray', Uint8ClampedArray.of(257, 256, -1, -2)],
  ['Int16Array', Int16Array.of(32767, 32766, 0, -32768)],
  ['Uint16Array', Uint16Array.of(65535, 65534, 65533, 0)],
  ['In32Array', Int32Array.of(2147483647, 2147483646, 0, -2147483648)],
  ['Uint32Array', Uint32Array.of(4294967295, 4294967294, 4294967293, 0)],
  ['Flaot32Array', Float32Array.of(1.0, 0.75, 0.5, 0.25)],
  ['Float64Array', Float64Array.of(1.0, 0.75, 0.5, 0.25)],
  ['DataView', new DataView(helloBuffer.buffer)],
];

// Empty buffers
const emptyBuffer = new Uint8Array(0);
const emptyBlob = new Blob([emptyBuffer]);

const channelOptionsVariants = [
  ['In-band negotiated channel', {}],
  ['Negotiated channel', [
    {
      negotiated: true,
      id: 42
    }, {
      negotiated: true,
      id: 42
    }
  ]],
  ['Asymmetric negotiated channel', [
    {
      negotiated: true,
      id: 42
    }, {
      negotiated: true,
      id: 42,
      // Note: Make sure that your tests can cope with unordered messages on the local side!
      ordered: false,
    }
  ]],
];

for (const [description, channelOptions] of channelOptionsVariants) {
  /*
      6.2.  send()
        2.  If channel's [[ReadyState]] slot is not open, throw an InvalidStateError.
   */
  test(t => {
    const pc = new RTCPeerConnection();
    const channel = pc.createDataChannel('test', channelOptions);
    assert_throws('InvalidStateError', () => channel.send(helloString));
  }, `${description}: Calling send() when not open should throw InvalidStateError`);

  /*
    6.2.  send()
      3.  Execute the sub step that corresponds to the type of the methods argument:

          string object
            Let data be a byte buffer that represents the result of encoding the
            method's argument as UTF-8 [...]

    TODO: Update this once https://github.com/w3c/webrtc-pc/issues/1825 is resolved

    [WebSocket]
    9.3.3.  When a WebSocket message has been received with type type and data data, the
            user agent must queue a task to follow these steps:
        2.  Let dataForEvent be determined by switching on type and binaryType:

            type indicates that the data is Text
              a new DOMString containing data
   */
  promise_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    return createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
    .then(([dc1, dc2]) => {
      dc1.send(helloString);
      return awaitMessage(dc2)
    })
    .then(message => {
      assert_equals(typeof message, 'string', 'Expect message to be a string');
      assert_equals(message, helloString);
    });
  }, `${description}: Should be able to send (local) simple string and receive (remote) as
  string`);

  promise_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    return createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
    .then(([dc1, dc2]) => {
      dc2.send(helloString);
      return awaitMessage(dc1)
    })
    .then(message => {
      assert_equals(typeof message, 'string', 'Expect message to be a string');
      assert_equals(message, helloString);
    });
  }, `${description}: Should be able to send (remote) simple string and receive (local) as
  string`);

  promise_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    return createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
    .then(([dc1, dc2]) => {
      dc1.send(unicodeString);
      return awaitMessage(dc2)
    })
    .then(message => {
      assert_equals(typeof message, 'string', 'Expect message to be a string');
      assert_equals(message, unicodeString);
    });
  }, `${description}: Should be able to send unicode string and receive as unicode string`);

  promise_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    return createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
    .then(([dc1, dc2]) => {
      dc2.binaryType = 'arraybuffer';
      dc1.send(helloString);
      return awaitMessage(dc2);
    })
    .then(message => {
      assert_equals(typeof message, 'string', 'Expect message to be a string');
      assert_equals(message, helloString);
    });
  }, `${description}: Should ignore binaryType and always receive string message as string`);

  /*
    6.2. send()
      3.  Execute the sub step that corresponds to the type of the methods argument:

          ArrayBufferView object
            Let data be the data stored in the section of the buffer described
            by the ArrayBuffer object that the ArrayBufferView object references
            and increase the value of the [[BufferedAmount]] slot with the the length
            of the ArrayBufferView in bytes.

    TODO: Update this once https://github.com/w3c/webrtc-pc/issues/1825 is resolved

    [WebSocket]
    9.3.3.  When a WebSocket message has been received with type type and data data, the
            user agent must queue a task to follow these steps:
        2.  Let dataForEvent be determined by switching on type and binaryType:

            type indicates that the data is Binary and binaryType is "arraybuffer"
              a new ArrayBuffer object, created in the relevant Realm of the WebSocket
              object, whose contents are data

    [WebIDL]
    4.1.  ArrayBufferView
      typedef (Int8Array or Int16Array or Int32Array or
        Uint8Array or Uint16Array or Uint32Array or Uint8ClampedArray or
        Float32Array or Float64Array or DataView) ArrayBufferView;
   */
  for (const [name, arrayBuffer] of arrayBuffers) {
    promise_test(t => {
      const pc1 = new RTCPeerConnection();
      const pc2 = new RTCPeerConnection();
      t.add_cleanup(() => pc1.close());
      t.add_cleanup(() => pc2.close());

      return createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
      .then(([dc1, dc2]) => {
        dc2.binaryType = 'arraybuffer';
        dc1.send(arrayBuffer);
        return awaitMessage(dc2)
      })
      .then(messageBuffer => {
        assert_true(messageBuffer instanceof ArrayBuffer,
          'Expect messageBuffer to be an ArrayBuffer');
        assert_equals_typed_array(messageBuffer, arrayBuffer);
      });
    }, `${description}: Should be able to send ${name} message and receive as ArrayBuffer`);
  }

  promise_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const helloBufferWithOffset = new Uint8Array(helloBuffer.buffer, 2);

    return createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
    .then(([dc1, dc2]) => {
      dc2.binaryType = 'arraybuffer';
      dc1.send(helloBufferWithOffset);
      return awaitMessage(dc2)
    })
    .then(messageBuffer => {
      assert_true(messageBuffer instanceof ArrayBuffer,
        'Expect messageBuffer to be an ArrayBuffer');
      assert_equals_typed_array(messageBuffer, helloBufferWithOffset);
    });
  }, `${description}: Should be able to send Uint8Array (with offset) message and receive as
  ArrayBuffer`);

  promise_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const helloView = new DataView(helloBuffer.buffer, 2);

    return createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
    .then(([dc1, dc2]) => {
      dc2.binaryType = 'arraybuffer';
      dc1.send(helloView);
      return awaitMessage(dc2)
    })
    .then(messageBuffer => {
      assert_true(messageBuffer instanceof ArrayBuffer,
        'Expect messageBuffer to be an ArrayBuffer');
      assert_equals_typed_array(messageBuffer, helloView);
    });
  }, `${description}: Should be able to send DataView (with offset) message and receive as
  ArrayBuffer`);

  /*
    6.2. send()
      3.  Execute the sub step that corresponds to the type of the methods argument:

          ArrayBuffer object
            Let data be the data stored in the buffer described by the ArrayBuffer
            object and increase the value of the [[BufferedAmount]] slot with the
            length of the ArrayBuffer in bytes.
   */
  promise_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    return createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
    .then(([dc1, dc2]) => {
      dc2.binaryType = 'arraybuffer';
      dc1.send(helloBuffer.buffer);
      return awaitMessage(dc2)
    })
    .then(messageBuffer => {
      assert_true(messageBuffer instanceof ArrayBuffer,
        'Expect messageBuffer to be an ArrayBuffer');
      assert_equals_typed_array(messageBuffer, helloBuffer);
    });
  }, `${description}: Should be able to send ArrayBuffer message and receive as ArrayBuffer`);

  /*
    6.2. send()
      3.  Execute the sub step that corresponds to the type of the methods argument:

          Blob object
            Let data be the raw data represented by the Blob object and increase the
            value of the [[BufferedAmount]] slot with the size of data, in bytes.
   */
  promise_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    return createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
    .then(([dc1, dc2]) => {
      dc2.binaryType = 'arraybuffer';
      dc1.send(helloBlob);
      return awaitMessage(dc2);
    })
    .then(messageBuffer => {
      assert_true(messageBuffer instanceof ArrayBuffer,
        'Expect messageBuffer to be an ArrayBuffer');
      assert_equals_typed_array(messageBuffer, helloBuffer);
    });
  }, `${description}: Should be able to send Blob message and receive as ArrayBuffer`);

  promise_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const slicedHelloBlob = helloBlob.slice(2);
    const helloBufferWithOffset = new Uint8Array(helloBuffer.buffer, 2);

    return createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
    .then(([dc1, dc2]) => {
      dc2.binaryType = 'arraybuffer';
      dc1.send(slicedHelloBlob);
      return awaitMessage(dc2);
    })
    .then(messageBuffer => {
      assert_true(messageBuffer instanceof ArrayBuffer,
        'Expect messageBuffer to be an ArrayBuffer');
      assert_equals_typed_array(messageBuffer, helloBufferWithOffset);
    });
  }, `${description}: Should be able to send Blob (with offset) message and receive as ArrayBuffer`);

  /*
    TODO: Update this once https://github.com/w3c/webrtc-pc/issues/1825 is resolved

    [WebSocket]
    9.3.3.  When a WebSocket message has been received with type type and data data, the
            user agent must queue a task to follow these steps:
        2.  Let dataForEvent be determined by switching on type and binaryType:

            type indicates that the data is Binary and binaryType is "blob"
              a new Blob object, created in the relevant Realm of the WebSocket object,
              that represents data as its raw data [FILEAPI]
   */
  promise_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    return createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
    .then(([dc1, dc2]) => {
      dc2.binaryType = 'blob';
      dc1.send(helloBuffer);
      return awaitMessage(dc2);
    })
    .then(messageBlob => {
      assert_true(messageBlob instanceof Blob,
        'Expect received messageBlob to be a Blob');
      return blobToArrayBuffer(messageBlob);
    })
    .then(messageBuffer => {
      assert_true(messageBuffer instanceof ArrayBuffer,
        'Expect messageBuffer to be an ArrayBuffer');
      assert_equals_typed_array(messageBuffer, helloBuffer);
    });
  }, `${description}: Should be able to send ArrayBuffer message and receive as Blob`);

  promise_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    return createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
    .then(([dc1, dc2]) => {
      dc1.send('');
      t.step_timeout(() => assert_unreached('Receiving empty string timed out'), 100);
      return awaitMessage(dc2)
    })
    .then(message => {
      assert_equals(message, '', 'Data should be an empty string');
    });
  }, `${description}: Should be able to transmit an empty string`);

  promise_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    return createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
    .then(([dc1, dc2]) => {
      dc2.binaryType = 'arraybuffer';
      dc1.send(emptyBuffer);
      t.step_timeout(() => assert_unreached('Receiving empty buffer timed out'), 100);
      return awaitMessage(dc2)
    })
    .then(messageBuffer => {
      assert_equals(messageBuffer.byteLength, 0, 'Data should be an empty ArrayBuffer');
    });
  }, `${description}: Should be able to transmit an empty Uint8Array`);

  promise_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    return createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
    .then(([dc1, dc2]) => {
      dc2.binaryType = 'blob';
      dc1.send(emptyBlob);
      t.step_timeout(() => assert_unreached('Receiving empty buffer timed out'), 100);
      return awaitMessage(dc2)
    })
    .then(messageBlob => {
      assert_equals(messageBlob.size, 0, 'Data should be an empty Blob');
    });
  }, `${description}: Should be able to transmit an empty Blob`);

  /*
    6.2.  RTCDataChannel
      binaryType
        The binaryType attribute MUST, on getting, return the value to which it was last
        set. On setting, if the new value is either the string "blob" or the string
        "arraybuffer", then set the IDL attribute to this new value. Otherwise, throw a
        SyntaxError. When an RTCDataChannel object is created, the binaryType attribute
        MUST be initialized to the string "blob".
   */
  test(t => {
    const pc = new RTCPeerConnection();
    const dc = pc.createDataChannel('test-binary-type', channelOptions);
    assert_throws('SyntaxError', () => {
      dc.binaryType = 'jellyfish';
    });
  }, `${description}: Setting binaryType should throw SyntaxError on unsupported type`);

  promise_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    return createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
    .then(([dc1, dc2]) => {
      assert_equals(dc2.binaryType, 'blob', 'Expect initial binaryType value to be blob');
      dc1.send(helloBuffer);
      return awaitMessage(dc2);
    })
    .then(messageBlob => {
      assert_true(messageBlob instanceof Blob, 'Expect received messageBlob to be a Blob');
      return blobToArrayBuffer(messageBlob);
    })
    .then(messageBuffer => {
      assert_true(messageBuffer instanceof ArrayBuffer,
        'Expect messageBuffer to be an ArrayBuffer');
      assert_equals_typed_array(messageBuffer, helloBuffer);
    });
  }, `${description}: Setting binaryType should receive message as Blob by default`);

  // Test sending 3 messages with different types on one channel:
  // helloBuffer, unicodeString, helloBlob
  async_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const receivedMessages = [];

    const onMessage = t.step_func(event => {
      const { data } = event;
      receivedMessages.push(data);

      if(receivedMessages.length === 3) {
        assert_equals_typed_array(receivedMessages[0], helloBuffer);
        assert_equals(receivedMessages[1], unicodeString);
        assert_equals_typed_array(receivedMessages[2], helloBuffer);

        t.done();
      }
    });

    createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
    .then(([dc1, dc2]) => {
      dc2.binaryType = 'arraybuffer';
      dc2.addEventListener('message', onMessage);

      dc1.send(helloBuffer);
      dc1.send(unicodeString);
      dc1.send(helloBlob);

    }).catch(t.step_func(err =>
      assert_unreached(`Unexpected promise rejection: ${err}`)));
  }, `${description}: Sending multiple messages with different types should succeed`);

  // Test receiving 4 messages with different types on one channel:
  // Blob, DOMString, ArrayBuffer, Blob
  async_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
    .then(([dc1, dc2]) => {
      const receivedMessages = [];

      dc2.onmessage = t.step_func(event => {
        const { data } = event;
        receivedMessages.push(data);
        dc2.binaryType = receivedMessages.length === 3 ? 'blob' : 'arraybuffer';

        if (receivedMessages.length === 4) {
          Promise.all([
            blobToArrayBuffer(receivedMessages[0]),
            blobToArrayBuffer(receivedMessages[3]),
          ])
          .then((blobMessages) => {
            receivedMessages[0] = blobMessages[0];
            receivedMessages[3] = blobMessages[1];

            assert_equals_typed_array(receivedMessages[0], helloBuffer);
            assert_equals(receivedMessages[1], unicodeString);
            assert_equals_typed_array(receivedMessages[2], helloBuffer);
            assert_equals_typed_array(receivedMessages[3], helloBuffer);

            t.done();
          });
        }
      });

      dc1.send(helloBuffer);
      dc1.send(unicodeString);
      dc1.send(helloBlob);
      dc1.send(helloBlob);

    }).catch(t.step_func(err =>
      assert_unreached(`Unexpected promise rejection: ${err}`)));
  }, `${description}: Receiving multiple messages with different types should succeed`);

  /*
    6.2.  send()
      4.  If the size of data exceeds the value of maxMessageSize on channel's
          associated RTCSctpTransport, throw a TypeError.

    Note: maxMessageSize is extensively tested in RTCSctpTransport-maxMessageSize. In
          this test, we only care about whether the data reaches the other peer as
          expected or that TypeError is correctly raised.
  */
  const messageLengths = [
    1024, // 1 KiB
    16384, // 16 KiB, was the maximum message size when sending from Firefox to Chrome
    65536, // 64 KiB, is the maximum message size in Chrome
    131072, // 128 KiB, violates the message-oriented principle when received by Chrome
    262144, // 256 KiB, is the default buffer size of usrsctp
    524288, // 512 KiB, > 256 KiB fails in Chrome by closing channels
    1048576, // 1 MiB
    16777216, // 16 MiB
    33554432, // 32 MiB
  ];
  for (const messageLength of messageLengths) {
    async_test(t => {
      const pc1 = new RTCPeerConnection();
      const pc2 = new RTCPeerConnection();
      t.add_cleanup(() => pc1.close());
      t.add_cleanup(() => pc2.close());

      const message = new Uint8Array(messageLength).fill(0xfe);

      createDataChannelPair(pc1, pc2, {
        channelLabel: '╯°□°）╯︵ ┻━┻',
        channelOptions: channelOptions
      })
      .then(([dc1, dc2]) => {
        dc2.binaryType = 'arraybuffer';

        // Ensure the channels are not being closed
        for (const dc of [dc1, dc2]) {
          dc.onclose = t.step_func(() => {
            assert_unreached('Channel should not become closed');
          });
        }

        // Ensure the data reaches the other peer (and the message-oriented principle is not
        // violated)
        dc2.onmessage = t.step_func(event => {
          const { data } = event;
          assert_equals_typed_array(data, message,
            'Send data should equal receive data');
          t.done();
        });

        // Send or fail with TypeError
        try {
          dc1.send(message);
        } catch (e) {
          assert_equals(e.name, 'TypeError',
            'Should throw TypeError in case the message is too large');
          t.done();
        }
      })
      .catch(t.step_func(err =>
        assert_unreached(`Unexpected promise rejection: ${err}`)));
    }, `${description}: Sending and receiving ${messageLength} bytes should succeed or raise
    TypeError`);

    async_test(t => {
      const pc1 = new RTCPeerConnection();
      const pc2 = new RTCPeerConnection();
      t.add_cleanup(() => pc1.close());
      t.add_cleanup(() => pc2.close());

      const message = new Uint8Array(messageLength + 1).fill(0xfe);

      createDataChannelPair(pc1, pc2, {
        channelLabel: '╯°□°）╯︵ ┻━┻',
        channelOptions: channelOptions,
        modifyAnswer: (answer) => {
          // Lower the remote maximum message size (if needed)
          const mmsAttribute = answer.sdp.match(/^a=max-message-size:(\d+)/m);
          let mms = mmsAttribute === null ? 65536 : parseInt(mmsAttribute[1], 10);
          if (mms === 0) {
            mms = Number.POSITIVE_INFINITY;
          }
          if (messageLength < mms) {
            if (mmsAttribute === null) {
              answer.sdp = answer.sdp.replace(
                /^(m=application \d+ [^ ]*DTLS\/SCTP[^\r\n]*\r\n)/m,
                `$1a=max-message-size:${messageLength}\r\n`);
            } else {
              answer.sdp = answer.sdp.replace(/^(a=max-message-size:)(\d+)/m, `$1${messageLength}`);
            }
          }
          return answer;
        }
      })
      .then(([dc1, dc2]) => {
        // Ensure the channels are not being closed
        for (const dc of [dc1, dc2]) {
          dc.onclose = t.step_func(() => {
            assert_unreached('Channel should not become closed');
          });
        }

        // Ensure no data reaches the other peer
        dc2.onmessage = t.step_func(event => {
          assert_unreached('Channel should not receive any data');
        });

        // Send or fail with TypeError
        assert_throws(new TypeError(), () => dc1.send(message),
          'Should throw TypeError in case the message is too large');
        dc1.send(message);

        // Give the implementation a chance to misbehave and close channels
        // Note: Tested that in Chrome and it really needs the long timeout
        t.step_timeout(t.step_func_done(), 10000)
      })
      .catch(t.step_func(err =>
        assert_unreached(`Unexpected promise rejection: ${err}`)));
    }, `${description}: Sending and receiving ${messageLength} +1 bytes should raise TypeError`);
  }

  async_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    // 16 KiB * 64 -> 1 MiB
    const message = new Uint8Array(16384).fill(0xfe);
    const nMessages = 64;

    createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
    .then(([dc1, dc2]) => {
      let nMessagesReceived = 0;
      dc2.binaryType = 'arraybuffer';

      // Ensure the data reaches dc2
      dc2.onmessage = t.step_func(event => {
        const {data} = event;
        assert_equals_typed_array(data, message,
          'Received data should be equal to sent data');
        if (++nMessagesReceived === nMessages) {
          t.done();
        }
      });

      // Send messages
      for (let i = 0; i < nMessages; ++i) {
        dc1.send(message);
      }
      t.step_timeout(() => {
        assert_unreached('Data should have been received by now (timeout reached)');
      }, 15000);
    }).catch(t.step_func(err =>
      assert_unreached(`Unexpected promise rejection: ${err}`)));
  }, `${description}: Sending and receiving 16 KiB x64 should succeed`);

  async_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    // 16 KiB * 256 -> 4 MiB
    const message = new Uint8Array(16384).fill(0xfe);
    const nMessages = 256;

    createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
    .then(([dc1, dc2]) => {
      let nMessagesReceived1 = 0;
      let nMessagesReceived2 = 0;
      dc1.binaryType = 'arraybuffer';
      dc2.binaryType = 'arraybuffer';

      const maybeDone = () => {
        if (nMessagesReceived1 === nMessages && nMessagesReceived2 === nMessages) {
          t.done();
        }
      };

      // Ensure the data reaches both peers
      dc1.onmessage = t.step_func(event => {
        const {data} = event;
        assert_equals_typed_array(data, message,
          'Received data should be equal to sent data');
        ++nMessagesReceived1;
        maybeDone();
      });
      dc2.onmessage = t.step_func(event => {
        const {data} = event;
        assert_equals_typed_array(data, message,
          'Received data should be equal to sent data');
        ++nMessagesReceived2;
        maybeDone();
      });

      // Send messages
      for (let i = 0; i < nMessages; ++i) {
        dc1.send(message);
        dc2.send(message);
      }
      t.step_timeout(() => {
        assert_unreached('Data should have been received by now (timeout reached)');
      }, 45000);
    }).catch(t.step_func(err =>
      assert_unreached(`Unexpected promise rejection: ${err}`)));
  }, `${description}: Sending and receiving 16 KiB x256 on both peer simultaneously should
  succeed`);

  // Based on https://bugzilla.mozilla.org/show_bug.cgi?id=1413198
  async_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    // Note: Since this is a race, we need a large amount of data. 1 MiB should be sufficient.
    //       We're assuming the implementation can queue at least 16 messages of size 64 KiB.
    //       The small message size has been chosen because every implementation supports 64 KiB.
    const message = new Uint8Array(65536).fill(0xfe);
    const nMessages = 16;

    createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
    .then(([dc1, dc2]) => {
      let nMessagesReceived = 0;
      dc2.binaryType = 'arraybuffer';

      // Ensure dc2 has received all messages once being closed
      dc2.onclose = t.step_func(() => {
        assert_equals(nMessagesReceived, nMessages,
          'Remote channel should have received all messages before becoming closed');
        t.done();
      });

      // Ensure the data reaches dc2
      dc2.onmessage = t.step_func(event => {
        const {data} = event;
        assert_equals_typed_array(data, message,
          'Received data should be equal to sent data');
        ++nMessagesReceived;
      });

      // Fill the send buffer as fast as possible and close immediately
      for (let i = 0; i < nMessages; ++i) {
        dc1.send(message);
      }
      dc1.close();
      t.step_timeout(() => {
        assert_unreached('Channel should have been closed by now (timeout reached)');
      }, 15000);
    }).catch(t.step_func(err =>
      assert_unreached(`Unexpected promise rejection: ${err}`)));
  }, `${description}: Closing a channel (local) with outstanding data should transfer that data
  before becoming closed`);

  // TODO: May need updating once https://github.com/w3c/webrtc-pc/issues/1825 has been resolved
  async_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    // Note: Since this is a race, we need a large amount of data. 1 MiB should be sufficient.
    //       We're assuming the implementation can queue at least 16 messages of size 64 KiB.
    //       The small message size has been chosen because every implementation supports 64 KiB.
    const message = new Uint8Array(65536).fill(0xfe);
    const nMessages = 16;

    createDataChannelPair(pc1, pc2, {
      channelLabel: '╯°□°）╯︵ ┻━┻',
      channelOptions: channelOptions
    })
    .then(([dc1, dc2]) => {
      let closed = false;
      let nMessagesReceived = 0;
      dc2.binaryType = 'arraybuffer';

      dc1.onclose = t.step_func(() => {
        closed = true;
      });

      // Ensure dc2 has received all messages once being closed
      dc2.onclose = t.step_func(() => {
        assert_equals(nMessagesReceived, nMessages,
          'Remote channel should have received all messages before becoming closed');
        t.done();
      });

      // Ensure the data reaches dc2
      dc2.onmessage = t.step_func(event => {
        const {data} = event;
        assert_equals_typed_array(data, message,
          'Received data should be equal to sent data');
        ++nMessagesReceived;
      });

      // Fill the send buffer as fast as possible and let the other side close
      for (let i = 0; i < nMessages; ++i) {
        dc1.send(message);
      }
      dc2.close();
      t.step_timeout(() => {
        assert_unreached('Channel should have been closed by now (timeout reached)');
      }, 15000);
    })
    .catch(t.step_func(err =>
      assert_unreached(`Unexpected promise rejection: ${err}`)));
  }, `${description}: Closing a channel (remote) with outstanding data should transfer that data
  before becoming closed`);

  promise_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    return createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
    .then(([dc1, _]) => {
      dc1.close();
      assert_throws('InvalidStateError', () => dc1.send(helloString));
    });
  }, `${description}: Sending after the channel has been closed (local) should raise
  InvalidStateError`);

  async_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
    .then(([dc1, dc2]) => {
      dc1.onclose = t.step_func(() => {
        assert_throws('InvalidStateError', () => dc1.send(helloString));
        t.done();
      });

      dc2.close();
    });
  }, `${description}: Sending after the channel has been closed (remote) should raise
  InvalidStateError`);

  promise_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    return createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
    .then(([dc1, _]) => {
      pc1.close();
      assert_throws('InvalidStateError', () => dc1.send(helloString));
    });
  }, `${description}: Sending after the peer connection has been closed (local) should raise
  InvalidStateError`);

  async_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    return createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
    .then(([dc1, _]) => {
      dc1.onclose = t.step_func(() => {
        assert_throws('InvalidStateError', () => dc1.send(helloString));
        t.done();
      });

      pc2.close();
    });
  }, `${description}: Sending after the peer connection has been closed (remote) should raise
  InvalidStateError`);
}

/*
  Untestable

  6.2.  send()
    2.  Queue data for transmission on channel's underlying data transport. If queuing
        data is not possible because not enough buffer space is available, throw an
        OperationError.

        NOTE
        The actual transmission of data occurs in parallel. If sending data leads to
        an SCTP-level error, the application will be notified asynchronously through
        onerror.
*/
</script>
