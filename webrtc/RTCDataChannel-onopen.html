<!doctype html>
<meta charset=utf-8>
<title>RTCDataChannel.onopen</title>
<script src=/resources/testharness.js></script>
<script src=/resources/testharnessreport.js></script>
<script src="RTCPeerConnection-helper.js"></script>
<script src="cross-browser-helper.js"></script>
<script>
'use strict';

// Test is based on the following revision:
// https://rawgit.com/w3c/webrtc-pc/1cc5bfc3ff18741033d804c4a71f7891242fb5b3/webrtc.html

/*
  6.2. When the user agent is to announce an RTCDataChannel as open, the user agent MUST queue a
       task to run the following steps:

       2. Let channel be the RTCDataChannel object to be announced.
       3. Set channel's [[ReadyState]] slot to open.
       4. Fire a simple event named open at channel.
 */

// Timeout: 3s/10s
cross_browser_test(async (t, signaling, offering) => {
  const pc = new RTCPeerConnection();
  t.add_cleanup(() => pc.close());
  const future = new Future();

  // Create an in-band negotiated channel
  if (offering) {
    const dc = pc.createDataChannel('onopen');

    // Wait for the channel to open
    dc.addEventListener('open', t.step_func(() => {
      assert_equals(dc.readyState, 'open', 'Channel should be open after open has fired');
      future.resolve();
    }), { once: true });
  } else {
    future.resolve();
  }

  // Bind candidate events and do offer/answer exchange
  signaling.exchangeCandidates(t, pc);
  await signaling.exchangeDescriptions(pc, offering);
  await future;
}, 'In-band channel: Open event should be fired (local) when the data channel opens', {
  timeout: 3000
});

// Timeout: 6s/10s
cross_browser_test(async (t, signaling, offering) => {
  const pc = new RTCPeerConnection();
  t.add_cleanup(() => pc.close());
  const future = new Future();

  // Create an in-band negotiated channel
  if (offering) {
    pc.createDataChannel('onopen');
    future.resolve();
  } else {
    // Wait for the channel
    pc.addEventListener('datachannel', t.step_func((event) => {
      const dc = event.channel;

      // Wait for the channel to open
      dc.addEventListener('open', t.step_func(() => {
        assert_equals(dc.readyState, 'open', 'Channel should be open after open has fired');
        future.resolve();
      }), { once: true });
    }), { once: true });
  }

  // Bind candidate events and do offer/answer exchange
  signaling.exchangeCandidates(t, pc);
  await signaling.exchangeDescriptions(pc, offering);
  await future;
}, 'In-band channel: Open event should be fired (remote) when the data channel opens', {
  timeout: 3000
});

// Timeout: 9s/10s
cross_browser_test(async (t, signaling, offering) => {
  const pc = new RTCPeerConnection();
  t.add_cleanup(() => pc.close());
  const future = new Future();

  // Create a negotiated channel
  const dc = pc.createDataChannel('onopen', {
    negotiated: true,
    id: 42
  });

  // Wait for the channel to open
  dc.addEventListener('open', t.step_func(() => {
    assert_equals(dc.readyState, 'open', 'Channel should be open after open has fired');
    future.resolve();
  }), { once: true });

  // Bind candidate events and do offer/answer exchange
  // Wait for the channel to open
  signaling.exchangeCandidates(t, pc);
  await signaling.exchangeDescriptions(pc, offering);
  await future.resolve();
}, 'Negotiated channel: Open event should be fired when the channels open', {
  timeout: 3000
});

</script>
