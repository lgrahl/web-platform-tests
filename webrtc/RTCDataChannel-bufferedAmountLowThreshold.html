<!doctype html>
<meta charset=utf-8>
<title>RTCDataChannel.bufferedAmountLowThreshold</title>
<script src=/resources/testharness.js></script>
<script src=/resources/testharnessreport.js></script>
<script src="RTCPeerConnection-helper.js"></script>
<script>
'use strict';

// Test is based on the following revision:
// https://rawgit.com/w3c/webrtc-pc/1cc5bfc3ff18741033d804c4a71f7891242fb5b3/webrtc.html

/*
  6.2. bufferedAmountLowThreshold

       The bufferedAmountLowThreshold attribute sets the threshold at which the bufferedAmount is
       considered to be low. When the bufferedAmount decreases from above this threshold to equal
       or below it, the bufferedamountlow event fires. The bufferedAmountLowThreshold is initially
       zero on each new RTCDataChannel, but the application may change its value at any time.

  13.  bufferedamountlow

       The RTCDataChannel object's bufferedAmount decreases from above its
       bufferedAmountLowThreshold to less than or equal to its bufferedAmountLowThreshold.
 */
async_test(t => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  const dc = pc1.createDataChannel('test');

  // Send once the channel opened
  dc.onopen = t.step_func(() => {
    dc.send('meow');
  });

  // Done once the event has been raised
  assert_equals(dc.bufferedAmountLowThreshold, 0,
    'bufferedAmountLowTreshold should be 0 by default');
  dc.onbufferedamountlow = t.step_func(() => {
    assert_equals(dc.bufferedAmount, 0, 'bufferedAmount should be 0 once the event has fired');
    t.done();
  });

  exchangeIceCandidates(pc1, pc2);
  doSignalingHandshake(pc1, pc2)
  .catch(t.step_func(err =>
    assert_unreached(`Unexpected promise rejection: ${err}`)));
}, 'bufferedamountlow event should fire once bufferedAmount <= 0 (default)');

async_test(t => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  const dc = pc1.createDataChannel('test');
  dc.bufferedAmountLowThreshold = 1;

  // Send once the channel opened
  dc.onopen = t.step_func(() => {
    dc.send('meow');
  });

  // Done once the event has been raised
  assert_equals(dc.bufferedAmountLowThreshold, 1, 'bufferedAmountLowTreshold should be 1');
  dc.onbufferedamountlow = t.step_func(() => {
    assert_less_than_equal(dc.bufferedAmount, 1,
      'bufferedAmount should be <= 1 once the event has fired');
    t.done();
  });

  exchangeIceCandidates(pc1, pc2);
  doSignalingHandshake(pc1, pc2)
  .catch(t.step_func(err =>
    assert_unreached(`Unexpected promise rejection: ${err}`)));
}, 'bufferedamountlow event should fire once bufferedAmount <= 1 (custom)');

async_test(t => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  const dc = pc1.createDataChannel('test');
  dc.bufferedAmountLowThreshold = 20;

  // Send once the channel opened
  dc.onopen = t.step_func(() => {
    dc.send('meow');
  });

  // Done once the event has been raised
  assert_equals(dc.bufferedAmountLowThreshold, 20, 'bufferedAmountLowTreshold should be 20');
  dc.onbufferedamountlow = t.step_func(() => {
    assert_less_than_equal(dc.bufferedAmount, 20,
      'bufferedAmount should be <= 20 once the event has fired');
    t.done();
  });

  exchangeIceCandidates(pc1, pc2);
  doSignalingHandshake(pc1, pc2)
  .catch(t.step_func(err =>
    assert_unreached(`Unexpected promise rejection: ${err}`)));
}, 'bufferedamountlow event should fire once bufferedAmount <= 20 (when sending less than that)');

async_test(t => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  const dc1 = pc1.createDataChannel('test');

  // Send once the channel opened
  dc1.onopen = t.step_func(() => {
    dc1.send('meow');
  });

  // Done once the event has been raised (and the other channel did not fire)
  dc1.onbufferedamountlow = t.step_func(() => {
    t.step_timeout(() => t.step_func_done(), 100);
  });

  const dc2 = pc1.createDataChannel('test-2');
  dc2.onbufferedamountlow = t.step_func(() => {
    assert_unreached('dc2 should not fire bufferedamountlow');
  });

  exchangeIceCandidates(pc1, pc2);
  doSignalingHandshake(pc1, pc2)
  .catch(t.step_func(err =>
    assert_unreached(`Unexpected promise rejection: ${err}`)));
}, 'bufferedamountlow event should not fire on other channels');

</script>
