<!doctype html>
<meta charset=utf-8>
<title>RTCPeerConnection.prototype.createDataChannel</title>
<script src=/resources/testharness.js></script>
<script src=/resources/testharnessreport.js></script>
<script src="RTCPeerConnection-helper.js"></script>
<script>
'use strict';

// Test is based on the following revision:
// https://rawgit.com/w3c/webrtc-pc/1cc5bfc3ff18741033d804c4a71f7891242fb5b3/webrtc.html

/*
  4.4.2.  RTCPeerConnection.close
    6.    Set the [[ReadyState]] slot of each of connection's RTCDataChannels to "closed".

  Note: This test assumes that the implementation can handle a minimum of 24 data channels.
 */
test(t => {
  const pc = new RTCPeerConnection();

  // Create 24 channels, some of them negotiated
  const channels = [];
  for (let i = 0; i < 24; ++i) {
    const options = {};
    if (i % 2 === 0) {
      options.negotiated = true;
      options.id = i;
    }
    const dc = pc.createDataChannel(`test-channel-${i}`, options);
    assert_not_equals(dc.readyState, 'closed',
      'Channel may not be closed before connection establishment');
    channels.push(dc);
  }

  // Stop!
  pc.close();

  // Note: The spec doesn't mention anything related to schedule 'close', so assuming it's sync
  for (const dc of channels) {
    assert_equals(dc.readyState, 'closed',
      'Channel should be closed after closing the peer connection');
  }
}, 'Closing the peer connection should close all channels (before connection establishment)');

for (const local of [true, false]) {
  promise_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const channels = [];

    return createDataChannelPair(pc1, pc2)
    .then(([dc1, dc2]) => {
      const id = dc1.id;
      assert_not_equals(dc1.readyState, 'closed',
        'Channel may not be closed after connection establishment');
      channels.push(dc1);
      assert_not_equals(dc2.readyState, 'closed',
        'Channel may not be closed after connection establishment');
      channels.push(dc2);

      // Create 23 further channels, some of them negotiated
      for (let i = id + 1; i < (id + 24); ++i) {
        const createChannel = (pc, options) => {
          const dc = pc.createDataChannel(`test-channel-${i}`, options);
          assert_not_equals(dc.readyState, 'closed',
            'Channel may not be closed after connection establishment');
          channels.push(dc);
        };

        const options = {};
        if ((local && i % 2 === 0) || (!local && i %2 === 1)) {
          options.negotiated = true;
          options.id = i;
        }

        // Note: We explicitly don't add negotiated channels to both sides to see if the
        //       implementation can cope with that.
        createChannel(local ? pc1 : pc2, options);
      }

      // Stop!
      (local ? pc1 : pc2).close();

      // Note: The spec doesn't mention anything related to schedule 'close', so assuming it's
      //       sync
      for (const dc of channels) {
        assert_equals(dc.readyState, 'closed',
          'Channel should be closed after closing the peer connection');
      }
    });
  }, `Closing the ${local ? 'local' : 'remote'} peer connection should close all channels (after
  connection establishment)`);
}

promise_test(t => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  return createDataChannelPair(pc1, pc2)
  .then(() => {
    // Stop!
    pc1.close();
    pc2.close();

    assert_equals(pc1.sctp.state, 'closed', 'RTCSctpTransport should be in the closed state');
    assert_equals(pc2.sctp.state, 'closed', 'RTCSctpTransport should be in the closed state');
  });
}, 'Closing the peer connection should set the SCTP transport to closed');

/*
  TODO: Cover all the other steps defined by 4.4.2.
 */
</script>
