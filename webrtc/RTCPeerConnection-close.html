<!doctype html>
<meta charset=utf-8>
<title>RTCPeerConnection.prototype.createDataChannel</title>
<script src=/resources/testharness.js></script>
<script src=/resources/testharnessreport.js></script>
<script src="RTCPeerConnection-helper.js"></script>
<script>
'use strict';

// Test is based on the following revision:
// https://rawgit.com/w3c/webrtc-pc/1cc5bfc3ff18741033d804c4a71f7891242fb5b3/webrtc.html

/*
  4.4.2.  RTCPeerConnection.close
    6.    Set the [[ReadyState]] slot of each of connection's RTCDataChannels to "closed".

  Note: This test assumes that the implementation can handle a minimum of 24 data channels.
 */
test(t => {
  const pc = new RTCPeerConnection();

  // Create 24 channels, some of them negotiated
  const channels = [];
  for (let i = 0; i < 24; ++i) {
    const options = {};
    if (i % 2 === 0) {
      options.negotiated = true;
      options.id = i;
    }
    const dc = pc.createDataChannel(`test-channel-${i}`, options);
    assert_not_equals(dc.readyState, 'closed',
      'Channel may not be closed before connection establishment');
    channels.push(dc);
  }

  // Stop!
  pc.close();

  // Note: The spec doesn't mention anything related to schedule 'close', so assuming it's sync
  for (const dc of channels) {
    assert_equals(dc.readyState, 'closed',
      'Channel should be closed after closing the peer connection');
  }
}, 'Closing the peer connection should close all channels (before connection establishment)');

promise_test(t => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  const channels = [];

  return createDataChannelPair(pc1, pc2)
  .then(([dc1, dc2]) => {
    assert_not_equals(dc1.readyState, 'closed',
      'Channel may not be closed after connection establishment');
    channels.push(dc1);
    assert_not_equals(dc2.readyState, 'closed',
      'Channel may not be closed after connection establishment');
    channels.push(dc2);

    // Create 23 further channels, some of them negotiated
    for (let i = 1; i < 24; ++i) {
      const options = {};
      if (i % 2 === 0) {
        options.negotiated = true;
        options.id = i;
      }
      const dc = pc1.createDataChannel(`test-channel-${i}`, options);
      assert_not_equals(dc.readyState, 'closed',
        'Channel may not be closed after connection establishment');
      channels.push(dc);
    }

    // Stop!
    pc1.close();
    pc2.close();

    // Note: The spec doesn't mention anything related to schedule 'close', so assuming it's
    //       sync
    for (const dc of channels) {
      assert_equals(dc.readyState, 'closed',
        'Channel should be closed after closing the peer connection');
    }
  });
}, 'Closing the peer connection should close all channels (after connection establishment)');

promise_test(t => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();

  return createDataChannelPair(pc1, pc2)
  .then(() => {
    // Stop!
    pc1.close();
    pc2.close();

    assert_equals(pc1.sctp.state, 'closed', 'RTCSctpTransport should be in the closed state');
    assert_equals(pc2.sctp.state, 'closed', 'RTCSctpTransport should be in the closed state');
  });
}, 'Closing the peer connection should set the SCTP transport to closed');

/*
  TODO: Cover all the other steps defined by 4.4.2.
 */
</script>
